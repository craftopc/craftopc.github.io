<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>House_of_BotCake</title><url>/posts/house_of_botcake/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html"><![CDATA[  0x01 åˆ©ç”¨èƒŒæ™¯ è‡ª glibc 2.29 å¼€å§‹åŠ å…¥äº†å¯¹ tcache çš„ double free æ£€æŸ¥, ä½¿å¾—ä¹‹å‰çš„ tcache double free å¤±æ•ˆ
æºç è§£è¯» tcache ç»“æž„ä½“
1 2 3 4 5 6 typedef struct tcache_entry { struct tcache_entry *next; //é“¾è¡¨æŒ‡é’ˆï¼Œå¯¹åº”chunkä¸­çš„fdå­—æ®µ /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //æŒ‡å‘æ‰€å±žçš„tcacheç»“æž„ä½“ï¼Œå¯¹åº”chunkä¸­çš„bkå­—æ®µ } tcache_entry; tcache è¢«ç½®å…¥é“¾è¡¨
1 2 3 4 5 6 7 8 9 10 11 12 13 14 static __always_inline void tcache_put(mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *)chunk2mem(chunk); /* Mark this chunk as &amp;#34;in the tcache&amp;#34; so the test in _int_free will detect a double free. */ e-&amp;gt;key = tcache; //è®¾ç½®æ‰€å±žçš„tcache e-&amp;gt;next = tcache-&amp;gt;entries[tc_idx];//å•é“¾è¡¨å¤´æ’æ³• tcache-&amp;gt;entries[tc_idx] = e; ++(tcache-&amp;gt;counts[tc_idx]); //è®¡æ•°å¢žåŠ  } tcache double free æ£€æŸ¥
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 size_t tc_idx = csize2tidx(size); //åªè¦tcacheä¸ä¸ºç©ºï¼Œå¹¶ä¸”è¿™ä¸ªchunkå±žäºŽtcacheç®¡è¾–èŒƒå›´ï¼Œé‚£ä¹ˆè¿™ä¸ªchunkå°±æœ‰å¯èƒ½å·²ç»åœ¨tcacheä¸­äº†ï¼Œæ‰€ä»¥éœ€è¦double freeæ£€æŸ¥ if (tcache != NULL &amp;amp;&amp;amp; tc_idx &amp;lt; â€¦  ]]></content></entry><entry><title>Hello_world</title><url>/posts/hello_world/</url><categories><category>test</category></categories><tags><tag>test</tag></tags><content type="html">  md test~ ðŸ¤”
  </content></entry></search>