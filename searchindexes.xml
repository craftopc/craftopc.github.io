<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>从零开始的 Pwn 之旅 - 深入了解 elf 文件</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-elf-%E6%96%87%E4%BB%B6/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html">  ELF 文件初识 ELF 文件即 Linux 下的可执行文件，ELF 是 Executable and Linkable Format 的缩写。它是一个标准的二进制文件格式，用于存储可执行文件、目标代码、共享库和核心转储等。
使用 Linux 内置命令 file 可以轻松查看文件类型：
1 2 3 4 5 $ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d1f6561268de19201ceee260d3a4f6662e1e70dd, for GNU/Linux 4.4.0, stripped ELF 64-bit LSB pie executable 部分表示这是一个 64 位的 ELF 文件，LSB 表示低位字节序，pie 表示位置无关可执行文件（Position Independent Executable）。 x86-64 表示这是一个 amd64(x86-64) 架构的可执行文件。 dynamically linked 表示这个可执行文件是动态链接的，意味着它依赖于共享库。 interpreter /lib64/ld-linux-x86-64.so.2 表示这个可执行文件使用的动态链接器是 /lib64/ld-linux-x86-64.so.2。 BuildID[sha1]=d1f6561268de19201ceee260d3a4f6662e1e70dd 是一个唯一的标识符，用于标识这个可执行文件的构建版本。 for GNU/Linux 4.4.0 表示这个可执行文件是为 GNU/Linux 4.4.0 版本构建的。 stripped 表示这个可执行文件已经被剥离了调试信息。 当 ELF 文件被赋予可执行属性时，直接在命令行中输入 ELF 文件路径即可执行该文件：
1 2 3 4 5 6 7 8 9 10 # 可执行文件在当期目录下 $ ./binary_file # 可执行文件在其他目录下(使用绝对路径) $ /bin/binary_file # 可执行文件在其他目录下(使用相对路径) $ …  </content></entry><entry><title>House_of_BotCake</title><url>/posts/house_of_botcake/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html"><![CDATA[  利用背景 自 glibc 2.29 开始加入了对 tcache 的 double free 检查, 使得之前的 tcache double free 失效
源码解读 tcache 结构体
1 2 3 4 5 6 typedef struct tcache_entry { struct tcache_entry *next; //链表指针，对应chunk中的fd字段 /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //指向所属的tcache结构体，对应chunk中的bk字段 } tcache_entry; tcache 被置入链表
1 2 3 4 5 6 7 8 9 10 11 12 13 14 static __always_inline void tcache_put(mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *)chunk2mem(chunk); /* Mark this chunk as &#34;in the tcache&#34; so the test in _int_free will detect a double free. */ e-&gt;key = tcache; //设置所属的tcache e-&gt;next = tcache-&gt;entries[tc_idx];//单链表头插法 tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]); //计数增加 } tcache double free 检查
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 size_t tc_idx = csize2tidx(size); // 只要tcache不为空，并且这个chunk属于tcache管辖范围，那么这个chunk就有可能已经在tcache中了，所以需要double free检查 if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) { /* Check to see if it&#39;s already in the tcache. */ tcache_entry *e = (tcache_entry *)chunk2mem(p); /* 如果是double free，那么put时key字段被设置了tcache，就会进入循环被检查出来 如果不是，那么key字段就是用户数据区域，可以视为随机的，只有1/(2^size_t)的可能行进入循环，然后循环发现并不是double free */ if (__glibc_unlikely(e-&gt;key == tcache))//剪枝 { tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(&#34;free(): double free detected in tcache 2&#34;); } if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) //通过检查，放入tcahce中 { tcache_put(p, tc_idx); return; } } 动态调试 可以清晰的看到 bk 字段即 key 指向当前线程的 tcache chunk 区域
利用手法 利用思路 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // detail: https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_botcake.c #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; int main() { // malloc chunks intptr_t *x[7]; for(int i=0; i&lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } intptr_t *prev = malloc(0x100); intptr_t *victim = malloc(0x100); malloc(0x10); // free to fill tcache bins for(int i=0; i&lt;7; i++){ free(x[i]); } free(victim); free(prev); // Now, victim and prev already merge malloc(0x100); // double free free(victim); return 0; } 利用详解 上述代码内存布局:
1 2 // line 20 free(victim); 1 2 // line 21 free(prev); 此时 prev chunk 和 victim chunk 已经合并
1 2 // line 23 malloc(0x100); 此时申请内存块首先会从 tcache bins 返回内存块
1 2 // line 25 free(victim); victim chunk 已经被链接进了 tcache bins
只要 malloc 到 prev chunk 这块内存，就可以进行 tcache poisoning attack
漏洞成因 此漏洞的造成是因为 tcache 的检查不严谨导致的, free 函数通过检测当前 chunk 大小是否在 tcache 范围内来判断 double free
1 2 3 4 5 6 7 8 if (__glibc_unlikely(e-&gt;key == tcache))//剪枝 { tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(&#34;free(): double free detected in tcache 2&#34;); } 没有考虑到 unsorted bins chunk 被置入 tcache 没有 key 的情况
利用示例 write here   ]]></content></entry><entry><title>Hello_world</title><url>/posts/hello_world/</url><categories><category>test</category></categories><tags><tag>test</tag></tags><content type="html">  md test~ 🤔
  </content></entry></search>