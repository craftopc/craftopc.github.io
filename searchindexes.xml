<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>House_of_BotCake</title><url>/posts/house_of_botcake/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html"><![CDATA[  0x01 利用背景 自 glibc 2.29 开始加入了对 tcache 的 double free 检查, 使得之前的 tcache double free 失效
源码解读 tcache 结构体
1 2 3 4 5 6 typedef struct tcache_entry { struct tcache_entry *next; //链表指针，对应chunk中的fd字段 /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //指向所属的tcache结构体，对应chunk中的bk字段 } tcache_entry; tcache 被置入链表
1 2 3 4 5 6 7 8 9 10 11 12 13 14 static __always_inline void tcache_put(mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *)chunk2mem(chunk); /* Mark this chunk as &amp;#34;in the tcache&amp;#34; so the test in _int_free will detect a double free. */ e-&amp;gt;key = tcache; //设置所属的tcache e-&amp;gt;next = tcache-&amp;gt;entries[tc_idx];//单链表头插法 tcache-&amp;gt;entries[tc_idx] = e; ++(tcache-&amp;gt;counts[tc_idx]); //计数增加 } tcache double free 检查
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 size_t tc_idx = csize2tidx(size); //只要tcache不为空，并且这个chunk属于tcache管辖范围，那么这个chunk就有可能已经在tcache中了，所以需要double free检查 if (tcache != NULL &amp;amp;&amp;amp; tc_idx &amp;lt; …  ]]></content></entry><entry><title>Hello_world</title><url>/posts/hello_world/</url><categories><category>test</category></categories><tags><tag>test</tag></tags><content type="html">  md test~ 🤔
  </content></entry></search>