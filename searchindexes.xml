<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>ä»é›¶å¼€å§‹çš„ Pwn ä¹‹æ—… - æ·±å…¥äº†è§£ elf æ–‡ä»¶</title><url>/posts/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-pwn-%E4%B9%8B%E6%97%85---%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-elf-%E6%96%87%E4%BB%B6/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html">  ELF æ–‡ä»¶åˆè¯† ELF æ–‡ä»¶å³ Linux ä¸‹çš„å¯æ‰§è¡Œæ–‡ä»¶ï¼ŒELF æ˜¯ Executable and Linkable Format çš„ç¼©å†™ã€‚å®ƒæ˜¯ä¸€ä¸ªæ ‡å‡†çš„äºŒè¿›åˆ¶æ–‡ä»¶æ ¼å¼ï¼Œç”¨äºå­˜å‚¨å¯æ‰§è¡Œæ–‡ä»¶ã€ç›®æ ‡ä»£ç ã€å…±äº«åº“å’Œæ ¸å¿ƒè½¬å‚¨ç­‰ã€‚
ä½¿ç”¨ Linux å†…ç½®å‘½ä»¤ file å¯ä»¥è½»æ¾æŸ¥çœ‹æ–‡ä»¶ç±»å‹ï¼š
1 2 3 4 5 $ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d1f6561268de19201ceee260d3a4f6662e1e70dd, for GNU/Linux 4.4.0, stripped ELF 64-bit LSB pie executable éƒ¨åˆ†è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ª 64 ä½çš„ ELF æ–‡ä»¶ï¼ŒLSB è¡¨ç¤ºä½ä½å­—èŠ‚åºï¼Œpie è¡¨ç¤ºä½ç½®æ— å…³å¯æ‰§è¡Œæ–‡ä»¶ï¼ˆPosition Independent Executableï¼‰ã€‚ x86-64 è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ª amd64(x86-64) æ¶æ„çš„å¯æ‰§è¡Œæ–‡ä»¶ã€‚ dynamically linked è¡¨ç¤ºè¿™ä¸ªå¯æ‰§è¡Œæ–‡ä»¶æ˜¯åŠ¨æ€é“¾æ¥çš„ï¼Œæ„å‘³ç€å®ƒä¾èµ–äºå…±äº«åº“ã€‚ interpreter /lib64/ld-linux-x86-64.so.2 è¡¨ç¤ºè¿™ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ä½¿ç”¨çš„åŠ¨æ€é“¾æ¥å™¨æ˜¯ /lib64/ld-linux-x86-64.so.2ã€‚ BuildID[sha1]=d1f6561268de19201ceee260d3a4f6662e1e70dd æ˜¯ä¸€ä¸ªå”¯ä¸€çš„æ ‡è¯†ç¬¦ï¼Œç”¨äºæ ‡è¯†è¿™ä¸ªå¯æ‰§è¡Œæ–‡ä»¶çš„æ„å»ºç‰ˆæœ¬ã€‚ for GNU/Linux 4.4.0 è¡¨ç¤ºè¿™ä¸ªå¯æ‰§è¡Œæ–‡ä»¶æ˜¯ä¸º GNU/Linux 4.4.0 ç‰ˆæœ¬æ„å»ºçš„ã€‚ stripped è¡¨ç¤ºè¿™ä¸ªå¯æ‰§è¡Œæ–‡ä»¶å·²ç»è¢«å‰¥ç¦»äº†è°ƒè¯•ä¿¡æ¯ã€‚ å½“ ELF æ–‡ä»¶è¢«èµ‹äºˆå¯æ‰§è¡Œå±æ€§æ—¶ï¼Œç›´æ¥åœ¨å‘½ä»¤è¡Œä¸­è¾“å…¥ ELF æ–‡ä»¶è·¯å¾„å³å¯æ‰§è¡Œè¯¥æ–‡ä»¶ï¼š
1 2 3 4 5 6 7 8 9 10 # å¯æ‰§è¡Œæ–‡ä»¶åœ¨å½“æœŸç›®å½•ä¸‹ $ ./binary_file # å¯æ‰§è¡Œæ–‡ä»¶åœ¨å…¶ä»–ç›®å½•ä¸‹(ä½¿ç”¨ç»å¯¹è·¯å¾„) $ /bin/binary_file # å¯æ‰§è¡Œæ–‡ä»¶åœ¨å…¶ä»–ç›®å½•ä¸‹(ä½¿ç”¨ç›¸å¯¹è·¯å¾„) $ â€¦  </content></entry><entry><title>House_of_BotCake</title><url>/posts/house_of_botcake/</url><categories><category>Ctf</category></categories><tags><tag>Pwn</tag><tag>Ctf</tag></tags><content type="html"><![CDATA[  åˆ©ç”¨èƒŒæ™¯ è‡ª glibc 2.29 å¼€å§‹åŠ å…¥äº†å¯¹ tcache çš„ double free æ£€æŸ¥, ä½¿å¾—ä¹‹å‰çš„ tcache double free å¤±æ•ˆ
æºç è§£è¯» tcache ç»“æ„ä½“
1 2 3 4 5 6 typedef struct tcache_entry { struct tcache_entry *next; //é“¾è¡¨æŒ‡é’ˆï¼Œå¯¹åº”chunkä¸­çš„fdå­—æ®µ /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //æŒ‡å‘æ‰€å±çš„tcacheç»“æ„ä½“ï¼Œå¯¹åº”chunkä¸­çš„bkå­—æ®µ } tcache_entry; tcache è¢«ç½®å…¥é“¾è¡¨
1 2 3 4 5 6 7 8 9 10 11 12 13 14 static __always_inline void tcache_put(mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *)chunk2mem(chunk); /* Mark this chunk as &#34;in the tcache&#34; so the test in _int_free will detect a double free. */ e-&gt;key = tcache; //è®¾ç½®æ‰€å±çš„tcache e-&gt;next = tcache-&gt;entries[tc_idx];//å•é“¾è¡¨å¤´æ’æ³• tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]); //è®¡æ•°å¢åŠ  } tcache double free æ£€æŸ¥
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 size_t tc_idx = csize2tidx(size); // åªè¦tcacheä¸ä¸ºç©ºï¼Œå¹¶ä¸”è¿™ä¸ªchunkå±äºtcacheç®¡è¾–èŒƒå›´ï¼Œé‚£ä¹ˆè¿™ä¸ªchunkå°±æœ‰å¯èƒ½å·²ç»åœ¨tcacheä¸­äº†ï¼Œæ‰€ä»¥éœ€è¦double freeæ£€æŸ¥ if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) { /* Check to see if it&#39;s already in the tcache. */ tcache_entry *e = (tcache_entry *)chunk2mem(p); /* å¦‚æœæ˜¯double freeï¼Œé‚£ä¹ˆputæ—¶keyå­—æ®µè¢«è®¾ç½®äº†tcacheï¼Œå°±ä¼šè¿›å…¥å¾ªç¯è¢«æ£€æŸ¥å‡ºæ¥ å¦‚æœä¸æ˜¯ï¼Œé‚£ä¹ˆkeyå­—æ®µå°±æ˜¯ç”¨æˆ·æ•°æ®åŒºåŸŸï¼Œå¯ä»¥è§†ä¸ºéšæœºçš„ï¼Œåªæœ‰1/(2^size_t)çš„å¯èƒ½è¡Œè¿›å…¥å¾ªç¯ï¼Œç„¶åå¾ªç¯å‘ç°å¹¶ä¸æ˜¯double free */ if (__glibc_unlikely(e-&gt;key == tcache))//å‰ªæ { tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(&#34;free(): double free detected in tcache 2&#34;); } if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) //é€šè¿‡æ£€æŸ¥ï¼Œæ”¾å…¥tcahceä¸­ { tcache_put(p, tc_idx); return; } } åŠ¨æ€è°ƒè¯• å¯ä»¥æ¸…æ™°çš„çœ‹åˆ° bk å­—æ®µå³ key æŒ‡å‘å½“å‰çº¿ç¨‹çš„ tcache chunk åŒºåŸŸ
åˆ©ç”¨æ‰‹æ³• åˆ©ç”¨æ€è·¯ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // detail: https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_botcake.c #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; int main() { // malloc chunks intptr_t *x[7]; for(int i=0; i&lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } intptr_t *prev = malloc(0x100); intptr_t *victim = malloc(0x100); malloc(0x10); // free to fill tcache bins for(int i=0; i&lt;7; i++){ free(x[i]); } free(victim); free(prev); // Now, victim and prev already merge malloc(0x100); // double free free(victim); return 0; } åˆ©ç”¨è¯¦è§£ ä¸Šè¿°ä»£ç å†…å­˜å¸ƒå±€:
1 2 // line 20 free(victim); 1 2 // line 21 free(prev); æ­¤æ—¶ prev chunk å’Œ victim chunk å·²ç»åˆå¹¶
1 2 // line 23 malloc(0x100); æ­¤æ—¶ç”³è¯·å†…å­˜å—é¦–å…ˆä¼šä» tcache bins è¿”å›å†…å­˜å—
1 2 // line 25 free(victim); victim chunk å·²ç»è¢«é“¾æ¥è¿›äº† tcache bins
åªè¦ malloc åˆ° prev chunk è¿™å—å†…å­˜ï¼Œå°±å¯ä»¥è¿›è¡Œ tcache poisoning attack
æ¼æ´æˆå›  æ­¤æ¼æ´çš„é€ æˆæ˜¯å› ä¸º tcache çš„æ£€æŸ¥ä¸ä¸¥è°¨å¯¼è‡´çš„, free å‡½æ•°é€šè¿‡æ£€æµ‹å½“å‰ chunk å¤§å°æ˜¯å¦åœ¨ tcache èŒƒå›´å†…æ¥åˆ¤æ–­ double free
1 2 3 4 5 6 7 8 if (__glibc_unlikely(e-&gt;key == tcache))//å‰ªæ { tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(&#34;free(): double free detected in tcache 2&#34;); } æ²¡æœ‰è€ƒè™‘åˆ° unsorted bins chunk è¢«ç½®å…¥ tcache æ²¡æœ‰ key çš„æƒ…å†µ
åˆ©ç”¨ç¤ºä¾‹ write here   ]]></content></entry><entry><title>Hello_world</title><url>/posts/hello_world/</url><categories><category>test</category></categories><tags><tag>test</tag></tags><content type="html">  md test~ ğŸ¤”
  </content></entry></search>